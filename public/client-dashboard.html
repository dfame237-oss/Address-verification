</div>

    <script src="bulk_verification_logic.js"></script>
    <script>
        // --- CONSTANTS AND STATE ---
        const API_BASE = '/api';
        const API_CLIENT = `${API_BASE}/client/index`;
        const API_ENDPOINT = "/api/verify-single-address"; // used by single verification
        // NOTE: API_BULK_JOBS is defined in bulk_verification_logic.js.
        // The previous error was caused by a stray word or comment here. Ensure this line is clean.
        const LOGIN_PAGE = "client-login.html";
        
        let planDetails = JSON.parse(localStorage.getItem('planDetails') || '{}');
const CLIENT_NAME = localStorage.getItem('clientName') || planDetails.clientName || planDetails.username || 'Client';
        let isPlanValid = true;
        
        const initialToken = localStorage.getItem('clientToken');
if (!initialToken) {
            window.location.href = LOGIN_PAGE;
}

        let activeJobPollInterval; 
        let globalJobsData = { inProgress: [], completed: [] };
// Storage for filtering (NEW)

        // --- HEARTBEAT FUNCTION (PUBLIC) ---
        async function sendHeartbeat() {
            const currentToken = localStorage.getItem('clientToken');
if (!currentToken) return;
            try {
                await authFetch(`${API_CLIENT}?action=activity`, { method: 'POST' });
} catch (e) {
                console.warn("Heartbeat failed, session may be invalid:", e);
}
        }

        // --- LOGOUT (PUBLIC) ---
        async function logout() {
            const tokenToNotify = localStorage.getItem('clientToken');
try {
                if (tokenToNotify) {
                    await fetch(`${API_CLIENT}?action=logout`, {
                        method: 'POST',
                        headers: {
         
                   'Authorization': `Bearer ${tokenToNotify}`,
                            'Content-Type': 'application/json'
                        }
                    });
}
            } catch (error) {
                console.warn("Could not notify server of logout:", error);
} finally {
                localStorage.clear();
window.location.href = LOGIN_PAGE;
            }
        }

        // --- authFetch (PUBLIC) ---
        async function authFetch(url, options = {}) {
            const currentToken = localStorage.getItem('clientToken');
if (!currentToken) {
                localStorage.clear();
window.location.href = LOGIN_PAGE;
                throw new Error("Session expired. Please log in again.");
}

            const defaultHeaders = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${currentToken}` };
const resp = await fetch(url, { ...options, headers: { ...defaultHeaders, ...(options.headers || {}) } });
if (resp.status === 401 || resp.status === 403) {
                let debugText = '';
try { debugText = await resp.text(); } catch(e){}
                console.warn('authFetch got 401/403 from', url, 'server message:', debugText);
localStorage.clear();
                window.location.href = LOGIN_PAGE;
                throw new Error("Session expired. Please log in again.");
}
            return resp;
}

        // --- Profile fetch (PUBLIC) ---
        async function fetchProfileData() {
            const currentToken = localStorage.getItem('clientToken');
if (!currentToken) {
                localStorage.clear();
window.location.href = LOGIN_PAGE;
                return;
            }

            try {
                const resp = await fetch(`${API_CLIENT}?action=profile`, {
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${currentToken}`, 'Content-Type': 'application/json' }
              
  });

                if (resp.status === 401) {
                    let bodyText = '';
try { bodyText = await resp.text(); } catch(e){}
                    console.warn('Profile fetch 401:', bodyText);
if (bodyText && bodyText.toLowerCase().includes('session invalidated')) {
                        openForceModal();
return;
                    }

                    updateUIFromLocalPlan();
return;
                }

                const json = await resp.json().catch(()=>null);
if (!resp.ok || !json || json.status === 'Error') {
                    console.warn('Profile fetch failed', resp.status, json);
updateUIFromLocalPlan();
                    return;
                }

                const pd = json.planDetails ||
{};
                // Correct assignment of data to planDetails
                planDetails = Object.assign({}, planDetails, pd);
localStorage.setItem('planDetails', JSON.stringify(planDetails));

                const rc = pd.remainingCredits;
                const creditsDisplay = rc === 'Unlimited' ?
'Unlimited' : (rc == null ? 'N/A' : Number(rc).toLocaleString());
                
                document.getElementById('plan-remaining-credits').textContent = creditsDisplay;
                document.getElementById('client-name-display').textContent = pd.clientName || CLIENT_NAME;
document.getElementById('profile-username').textContent = pd.username || pd.clientName || CLIENT_NAME;
                document.getElementById('profile-email').textContent = pd.email || 'â€”';
                document.getElementById('profile-mobile').textContent = pd.mobile || 'â€”';
document.getElementById('profile-bulk-code').textContent = pd.bulkAccessCode || 'N/A';
                document.getElementById('plan-name').textContent = (pd.planName || 'Not Set').split('_')[0];
                document.getElementById('validity-end').textContent = pd.validityEnd ? new Date(pd.validityEnd).toLocaleDateString() : 'N/A';
const statusEl = document.getElementById('account-status');
                const isActive = (typeof pd.isActive === 'undefined') ? true : pd.isActive;
                statusEl.textContent = isActive ?
'Enabled' : 'Disabled';
                statusEl.className = `plan-status-badge ${isActive ? 'status-enabled' : 'status-disabled'}`;

                checkPlanValidity();
// --- Enterprise Improvement: Load Chart Data (Placeholder API) ---
                if (document.getElementById('usage-chart')) {
                    fetchUsageData().then(data => {
                        if (data) {
                         
   renderUsageChart(data);
                        }
                    }).catch(console.error);
}

            } catch (e) {
                console.error('fetchProfileData error:', e);
updateUIFromLocalPlan();
            }
        }
        
        // --- Enterprise Improvement: Usage Data (Placeholder) ---
        async function fetchUsageData() {
            // NOTE: This assumes a new API endpoint exists to fetch credits used per day for the last 30 days.
// Example Placeholder Data structure (replace with actual authFetch to your backend):
            const placeholderData = {
                labels: ['Day 1', 'Day 6', 'Day 12', 'Day 18', 'Day 24', 'Day 30'],
                creditsUsed: [250, 150, 400, 300, 500, 200]
            };
// Simulate API latency
            await new Promise(resolve => setTimeout(resolve, 300));
return placeholderData;
        }

        let usageChartInstance = null;
function renderUsageChart(data) {
            if (usageChartInstance) {
                usageChartInstance.destroy();
}
            const ctx = document.getElementById('usage-chart').getContext('2d');
usageChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.labels,
                    datasets: [{
                    
    label: 'Credits Used',
                        data: data.creditsUsed,
                        borderColor: '#A437C1',
                        backgroundColor: 'rgba(164, 55, 193, 0.1)',
                
        tension: 0.3,
                        fill: true,
                        pointRadius: 4,
                        pointBackgroundColor: '#5F3DC4'
                
    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: 
{
                        y: {
                            beginAtZero: true,
                            title: {
                 
               display: true,
                                text: 'Credits'
                            }
                       
 }
                    },
                    plugins: {
                        legend: {
                            display: false
    
                    },
                        tooltip: {
                            mode: 'index',
                          
  intersect: false,
                        }
                    }
                }
            });
}


        // --- Update UI from Local Plan (PUBLIC) ---
        function updateUIFromLocalPlan() {
            const rc = planDetails.remainingCredits ??
'N/A';
            const creditsDisplay = rc === 'Unlimited' ? 'Unlimited' : (rc === 'N/A' ? 'N/A' : Number(rc).toLocaleString());
            document.getElementById('plan-remaining-credits').textContent = creditsDisplay;
document.getElementById('client-name-display').textContent = CLIENT_NAME;
            document.getElementById('profile-username').textContent = planDetails.username || CLIENT_NAME;
            document.getElementById('profile-email').textContent = planDetails.email || 'â€”';
            document.getElementById('profile-mobile').textContent = planDetails.mobile || 'â€”';
document.getElementById('profile-bulk-code').textContent = planDetails.bulkAccessCode || 'N/A';
            document.getElementById('plan-name').textContent = (planDetails.planName || 'Not Set').split('_')[0];
            document.getElementById('validity-end').textContent = planDetails.validityEnd ? new Date(planDetails.validityEnd).toLocaleDateString() : 'N/A';
const statusEl = document.getElementById('account-status');
            const isActive = (typeof planDetails.isActive === 'undefined') ? true : planDetails.isActive; 
            statusEl.textContent = isActive ?
'Enabled' : 'Disabled';
            statusEl.className = `plan-status-badge ${isActive ? 'status-enabled' : 'status-disabled'}`;
}

        // --- CHECK PLAN VALIDITY (PUBLIC) ---
        function checkPlanValidity() {
            const token = localStorage.getItem('clientToken');
const planDetailsString = localStorage.getItem('planDetails');

            if (!token) {
                showAccessDenied("Please log in to access Bulk Address Verification.");
isPlanValid = false;
                return false;
            }

            try {
                const validityEnd = planDetails.validityEnd ?
new Date(planDetails.validityEnd) : null;
                const now = new Date();

                if (planDetails.isActive === false) {
                    showAccessDenied("Your account has been **disabled** by the administrator. Please contact support.");
isPlanValid = false;
                    return false;
                }

                if (validityEnd && validityEnd < now) {
                    showAccessDenied(`Your bulk plan expired on **${validityEnd.toLocaleDateString()}**. Please contact support to renew.`);
isPlanValid = false;
                    return false;
                }

                // OK
                document.getElementById('bulkContent').classList.remove('hidden');
                const progressContainer = document.querySelector('#bulk-verification .progress-container');
                if (progressContainer) progressContainer.classList.remove('hidden'); 
isPlanValid = true;
                return true;

            } catch (e) {
                console.error("Error parsing plan details:", e);
showAccessDenied("Client authentication data is corrupted. Please log in again.");
                setTimeout(() => { localStorage.clear(); window.location.href = LOGIN_PAGE; }, 1500);
isPlanValid = false;
                return false;
            }
        }

        // --- SHOW ACCESS DENIED (PUBLIC) ---
        function showAccessDenied(message) {
            const bulkContent = document.getElementById('bulkContent');
const progressContainer = document.querySelector('#bulk-verification .progress-container');
            if (bulkContent) bulkContent.classList.add('hidden');
            if (progressContainer) progressContainer.classList.add('hidden');

            const existing = document.querySelector('#bulk-verification .access-denied-block');
            if (existing) return;
const errorBlock = document.createElement('div');
            errorBlock.className = 'access-denied-block space-y-6 mt-6';
            errorBlock.innerHTML = `
                <div class="bg-red-50 p-8 rounded-xl border-l-4 border-alert-dark shadow-lg">
                    <p class="font-bold text-xl text-alert-dark mb-3 flex items-center">ðŸ›‘ Access Denied</p>
                    <p class="text-base text-gray-700 mb-6">${message.replace(/\*\*/g, '<strong>')}</p>
               
 </div>
                <a href="tel:+919193246219" class="block w-full py-3 bg-tf-secondary text-white text-center font-bold rounded-lg hover:bg-[#86259d] transition">Call Support / Renew Plan</a>
                <a href="https://wa.me/919193246219" target="_blank" class="block w-full py-3 bg-whatsapp-green text-white text-center font-bold rounded-lg hover:bg-green-600">ðŸŸ¢ WhatsApp Support</a>
            `;
document.getElementById('bulk-verification').appendChild(errorBlock);
        }

        // --- PASSWORD MODAL LOGIC (PUBLIC) ---
        function openPasswordModal() {
            document.getElementById('password-modal').style.display = 'flex';
document.getElementById('password-update-form').reset();
            document.getElementById('password-update-status').textContent = '';
        }

        function closePasswordModal() {
            document.getElementById('password-modal').style.display = 'none';
}
        
        // --- FORCE-LOGOUT UI / helpers (PUBLIC) ---
        function openForceModal() {
            document.getElementById('force-logout-modal').style.display = 'flex';
}
        function closeForceModal() {
            document.getElementById('force-logout-modal').style.display = 'none';
}

        function getTokenPayload() {
            const token = localStorage.getItem('clientToken');
if (!token) return null;
            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
return payload;
            } catch (e) {
                return null;
}
        }

        async function forceLogoutOtherDevice() {
            const payload = getTokenPayload();
const clientId = payload && payload.clientId ? payload.clientId : (planDetails.id || planDetails.clientId);
if (!clientId) {
                alert('Cannot determine clientId. Please log in again.');
closeForceModal();
                localStorage.clear();
                window.location.href = LOGIN_PAGE;
                return;
            }

            try {
                const resp = await fetch(`${API_CLIENT}?action=force-logout`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
               
     body: JSON.stringify({ clientId })
                });
const json = await resp.json().catch(()=>null);
                if (resp.ok && json && json.status === 'Success') {
                    closeForceModal();
localStorage.removeItem('clientToken');
                    alert('Other device logged out. Please log in again here.');
                    window.location.href = LOGIN_PAGE;
} else {
                    console.warn('force-logout failed', resp.status, json);
alert('Could not force logout other device. Contact support.');
                    closeForceModal();
                }
            } catch (e) {
                console.error('force-logout error', e);
alert('Network error. Try again or contact support.');
                closeForceModal();
            }
        }
        
        // --- INBOX FUNCTIONS (PUBLIC) ---
        async function loadInboxCounts() {
            try {
                const response = await authFetch(`${API_BASE}/inbox/message`);
const result = await response.json();
                if (result.status === "Success" && result.unreadCount > 0) {
                    const badge = document.getElementById('inbox-badge');
badge.textContent = result.unreadCount;
                    badge.style.display = 'block';
                } else {
                    document.getElementById('inbox-badge').style.display = 'none';
}
            } catch (e) {
                console.error("Failed to load client inbox counts:", e);
}
        }

        async function loadClientInbox() {
            const msgContainer = document.getElementById('client-inbox-list');
const detailView = document.getElementById('full-message-detail');
            msgContainer.innerHTML = '<p class="text-center text-gray-500 mt-5">Loading messages...</p>';
            detailView.style.display = 'none';
try {
                const response = await authFetch(`${API_BASE}/inbox/message`);
const result = await response.json();
                if (result.status === "Success") {
                    msgContainer.innerHTML = '';
if (!result.messages || result.messages.length === 0) {
                        msgContainer.innerHTML = '<p class="text-center text-gray-500 mt-5">No messages in your inbox.</p>';
return;
                    }
                    result.messages.forEach(msg => {
                        const isUnread = !msg.isRead && msg.senderId === 'admin';
                        const cardClass = isUnread ? 'unread' : '';
    
           
             const icon = isUnread ? 'fa-envelope' : 'fa-envelope-open';
                        const sender = msg.senderId === 'admin' ? 'Admin' : 'You';
    
                        // FIX: Use JSON.stringify for subject/body when passing to onclick to handle quotes/special characters
      
                  const subjectSafe = JSON.stringify(msg.subject || '(No Subject)');
                        const bodySafe = JSON.stringify(msg.body || '');

                        const messageHtml = `
                    
        <div id="msg-${msg._id}" class="msg-card ${cardClass}" onclick="viewClientMessage('${msg._id}', ${subjectSafe}, ${bodySafe}, ${isUnread}, '${msg.timestamp}')">
                                <i class="fas ${icon} msg-icon"></i>
                                <div class="flex-grow">
                
                    <p class="text-md truncate">${msg.subject ||
'(No Subject)'}</p>
                                    <small class="text-gray-500 block">From: ${sender} â€¢ ${new Date(msg.timestamp).toLocaleDateString()}</small>
                                </div>
                         
   </div>
                        `;
msgContainer.insertAdjacentHTML('beforeend', messageHtml);
                    });
                } else {
                    msgContainer.innerHTML = `<p class="text-center text-red-500 mt-5">Failed to load inbox: ${result.message}</p>`;
}
            } catch (error) {
                msgContainer.innerHTML = `<p class="text-center text-red-500 mt-5">Network Error: ${error.message}</p>`;
}
        }

        function toggleInbox() {
            document.getElementById('inbox-modal').style.display = 'flex';
loadClientInbox();
        }

        function closeInbox() {
            document.getElementById('inbox-modal').style.display = 'none';
loadInboxCounts();
        }

        function viewClientMessage(messageId, subject, body, isUnread, timestamp) {
            const detailView = document.getElementById('full-message-detail');
document.getElementById('full-message-subject').textContent = subject;
            // FIX: Use innerText for body to avoid injection and respect whitespace
            document.getElementById('full-message-body').innerText = body;
document.getElementById('full-message-date').textContent = new Date(timestamp).toLocaleString();
            detailView.style.display = 'block';
            if (isUnread) {
                authFetch(`${API_BASE}/inbox/message?messageId=${messageId}`, { method: 'PUT' }).catch(()=>{});
const card = document.getElementById(`msg-${messageId}`);
                if (card) {
                    card.classList.remove('unread');
const iconEl = card.querySelector('.msg-icon');
                    if (iconEl) iconEl.classList.replace('fa-envelope', 'fa-envelope-open');
                }
                setTimeout(loadInboxCounts, 500);
}
        }

        // --- TAB NAVIGATION (UPDATED and PUBLIC) ---
        function showTab(tabId, button) {
            document.querySelectorAll('.tab-content').forEach(el => el.style.display = 'none');
document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabId).style.display = 'block';
            if (button) button.classList.add('active');

            // Stop polling when leaving job tabs (NEW)
            if (activeJobPollInterval) {
                clearInterval(activeJobPollInterval);
activeJobPollInterval = null;
            }
            
            if (tabId === 'bulk-verification') {
                checkPlanValidity();
// Enterprise Improvement: Call function to load KPI data
                if (typeof loadKpiData === 'function') loadKpiData();
} else if (tabId === 'profile-plan') {
                fetchProfileData();
// Ensure fresh data on tab click
            } else if (tabId === 'in-progress-jobs' || tabId === 'completed-jobs') {
                // Requirements 2, 3, 5: Start polling for status when entering job tabs (NEW)
                startJobPolling();
}
        }
        
        // --- JOB POLLING LOGIC (PUBLIC) ---
        // Enterprise Improvement: Filter search is integrated here
        function startJobPolling() {
            if (activeJobPollInterval) clearInterval(activeJobPollInterval);
fetchAndUpdateJobStatus(); // Initial fetch
            activeJobPollInterval = setInterval(fetchAndUpdateJobStatus, 5000);
// Poll every 5 seconds
            
            // Add listeners for filtering (NEW)
            document.getElementById('in-progress-search')?.addEventListener('input', filterJobsList);
document.getElementById('completed-search')?.addEventListener('input', filterJobsList);
        }

        // --- Enterprise Improvement: Job Filtering Logic ---
        function filterJobsList() {
            const activeSearchTerm = document.getElementById('in-progress-search')?.value.toLowerCase() ||
'';
            const completedSearchTerm = document.getElementById('completed-search')?.value.toLowerCase() || '';
            
            // Render In Progress list (filtered)
            renderJobsList(globalJobsData.inProgress, 'in-progress-list', activeSearchTerm);
// Render Completed list (filtered)
            renderJobsList(globalJobsData.completed, 'completed-list', completedSearchTerm);
}

        // Reusable function to render job lists (NEW)
        function renderJobsList(jobs, containerId, searchTerm) {
            const container = document.getElementById(containerId);
let filteredJobs = jobs;

            if (searchTerm) {
                filteredJobs = jobs.filter(job => 
                    job.filename.toLowerCase().includes(searchTerm) || 
                    job._id.toLowerCase().includes(searchTerm)
                );
}
            
            let html = '';
let activeCount = 0; // Only count active jobs for the active job counter

            for (const job of filteredJobs) {
                const progress = job.totalRows > 0 ?
((job.processedCount / job.totalRows) * 100).toFixed(0) : 0;
                const isFailed = job.status === 'Failed';
                const isCompleted = job.status === 'Completed';
// Show only 10 completed jobs unless filtering is active
                if (containerId === 'completed-list' && !searchTerm && html.split('job-card').length > 10) continue;
const completionDisplay = isCompleted ? formatISTTime(job.completedTime) : new Date(job.submittedAt).toLocaleDateString();

                if (job.status === 'In Progress' || job.status === 'Queued') {
                    activeCount++;
// Count only for active list
                }
                
                const cardHtml = `
                    <div class="job-card bg-white p-4 rounded-lg shadow-md border-l-4 ${isCompleted ? 'border-green-500' : isFailed || job.status === 'Cancelled' ? 'border-red-500' : 'border-tf-secondary'}">
     
                   <div class="flex justify-between items-start mb-2">
                            <h4 class="font-bold text-lg text-gray-800 truncate">${job.filename}</h4>
                            <span class="text-sm font-semibold text-gray-600">${completionDisplay}</span>
              
          </div>
                        <div class="text-sm text-gray-600 mb-2 space-y-1">
                            <p><strong>Status:</strong> <span class="font-bold text-${isCompleted ? 'green' : isFailed || job.status === 'Cancelled' ? 'red' : 'tf-secondary'}-600">${job.status}</span></p>
                   
         ${job.status !== 'Cancelled' && job.status !== 'Failed' ?
`<p><strong>Rows:</strong> ${job.processedCount} / ${job.totalRows}</p>` : ''}
                        </div>
                        ${job.status === 'In Progress' ?
`
                        <div class="progress-bar w-full bg-gray-300 rounded-full h-2 mt-2">
                            <div class="progress-fill h-2 bg-tf-secondary rounded-full" style="width: ${progress}%;"></div>
                        </div>
            
            ` : ''}
                        <div class="mt-3 flex gap-2 justify-end">
                            ${job.status === 'In Progress' ||
job.status === 'Queued' ? `
                                <button class="py-1 px-3 bg-red-500 text-white text-sm rounded hover:bg-red-600" onclick="handleCancelJob('${job._id}')">
                                    <i class="fas fa-times"></i> Cancel
                 
               </button>` 
                            : isCompleted ?
`
                                <button class="py-1 px-3 bg-tf-primary text-white text-sm rounded hover:bg-[#4d2e97] transition" onclick="handleAuthenticatedDownload('${job._id}', '${job.filename.replace(/'/g, "\\'").replace(/"/g, '')}')">
                                    <i class="fas fa-download"></i> Download
                 
               </button>`
                            : isFailed ? `<span class="text-red-500 text-sm italic">${job.error || 'Check server logs.'}</span>`
                            : job.status === 'Cancelled' ? `<span class="text-red-500 text-sm italic">Cancelled by user.</span>`
         
                   : ''}
                        </div>
                    </div>
                `;
                
    
            html += cardHtml;
            }

            container.innerHTML = html || `<p class="text-gray-500 text-center mt-5">No jobs found matching the filter.</p>`;
            
            // Only update the active job counter if we are rendering the in-progress list without filtering.
if (containerId === 'in-progress-list' && !document.getElementById('in-progress-search')?.value) {
                document.getElementById('active-job-count').textContent = activeCount;
// Update bulk button state based on actual total active jobs (NEW)
                const processBtn = document.getElementById('processButton');
const bulkTabBtn = document.getElementById('bulk-tab-btn');
                const csvFileInput = document.getElementById('csvFileInput');
                
                if (activeCount >= 1) { 
                    if (processBtn) processBtn.disabled = true;
if (bulkTabBtn) bulkTabBtn.style.borderBottom = '2px solid #EF4444';
                    document.getElementById('max-jobs-message').style.display = 'block';
} else {
                    if (processBtn && csvFileInput) processBtn.disabled = !csvFileInput.files.length;
if (bulkTabBtn) bulkTabBtn.style.borderBottom = '2px solid #5F3DC4';
                    document.getElementById('max-jobs-message').style.display = 'none';
}
            }

            // Update refresh timestamp (NEW)
            document.getElementById(containerId.replace('-list', '-status-timestamp')).textContent = `Last refreshed: ${new Date().toLocaleTimeString()}`;
}
        
        async function fetchAndUpdateJobStatus() {
            try {
                const resp = await authFetch(API_BULK_JOBS, { method: 'GET' });
const result = await resp.json();

                if (result.status !== 'Success') {
                    console.error('Failed to fetch job status:', result.message);
return;
                }

                // Sort by submitted time descending
                result.jobs.sort((a, b) => new Date(b.submittedAt) - new Date(a.submittedAt));
globalJobsData.inProgress = result.jobs.filter(j => j.status === 'Queued' || j.status === 'In Progress');
globalJobsData.completed = result.jobs.filter(j => j.status === 'Completed' || j.status === 'Failed' || j.status === 'Cancelled');
// Re-render based on current filter state
                filterJobsList();
// Update remaining credits UI (post-completion check)
                const afterCreditsResp = await getRemainingCredits();
if (afterCreditsResp.ok) {
                    const rc = afterCreditsResp.remainingCredits;
const remEl = document.getElementById('plan-remaining-credits');
                    if (remEl) remEl.textContent = rc === 'Unlimited' ? 'Unlimited' : Number(rc).toLocaleString();
}
                
                // CRITICAL FIX: Ensure KPI is updated after polling is complete
                if (typeof loadKpiData === 'function') loadKpiData();

            } catch (e) {
                console.error('Job polling failed:', e);
document.getElementById('in-progress-list').innerHTML = '<p class="text-red-500 text-center mt-5">Failed to load status. Network error.</p>';
}
        }
        
        // --- Enterprise Improvement: KPI Data Logic (Updated) ---
        async function loadKpiData() {
            // Get today's completed rows from the global job data
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let completedToday = 0;
            
            // Check if globalJobsData has been populated by the poller
            if (globalJobsData.completed) {
                globalJobsData.completed.forEach(job => {
                    const completedTime = job.completedTime || job.submittedAt;
                    if (completedTime) {
                        const completedDate = new Date(completedTime);
                        if (job.status === 'Completed' && completedDate >= today) {
                            completedToday += job.totalRows;
                        }
                    }
                });
            }

            document.getElementById('today-completed-kpi').textContent = completedToday.toLocaleString();
        }

        // --- AUTHENTICATED DOWNLOAD FUNCTION ---
        async function handleAuthenticatedDownload(jobId, jobFilename) {
            const safeFilename = `${jobFilename.replace('.csv', '').replace(/'/g, '').replace(/"/g, '')}_verified.csv`;
            const downloadUrl = `${API_BULK_JOBS}?action=download&jobId=${jobId}`; 

            try {
              
  const resp = await authFetch(downloadUrl, { method: 'GET' });

                const contentType = (resp.headers.get && resp.headers.get('content-type') || '').toLowerCase();
                if (contentType.includes('application/json')) {
                    let json = null;
                    try { json = await resp.json(); 
} catch (e) { /* ignore parse error */ }
                    const msg = (json && (json.message || json.error)) ? (json.message || json.error) : 'Server returned JSON instead of CSV.';
                    alert('Download failed: ' + msg);
                    return;
}

                if (!resp.ok) {
                    const errorText = await resp.text();
try {
                        const errorJson = JSON.parse(errorText);
alert('Download failed: ' + (errorJson.message || errorJson.error || 'File unavailable.'));
} catch (e) {
                        alert('Download failed. Please try again later.');
}
                    return;
}

                const blob = await resp.blob();
const a = document.createElement('a');
                a.style.display = 'none';
                a.href = window.URL.createObjectURL(blob);
                a.download = safeFilename; 
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(a.href);
                a.remove();
} catch (e) {
                console.error("Authenticated Download Failed:", e);
alert('Download failed due to a network or authentication error.');
            }
        }
        
        // Make core functions available globally for HTML onclick events
        window.showTab = showTab;
window.logout = logout; 
        window.openPasswordModal = openPasswordModal;
        window.closePasswordModal = closePasswordModal;
        window.closeForceModal = closeForceModal;
        window.forceLogoutOtherDevice = forceLogoutOtherDevice;
        window.toggleInbox = toggleInbox;
window.closeInbox = closeInbox;
        window.viewClientMessage = viewClientMessage;
        window.handleAuthenticatedDownload = handleAuthenticatedDownload;
        window.filterJobsList = filterJobsList;
// Expose filter function (NEW)
        window.loadKpiData = loadKpiData;


        // --- PASSWORD UPDATE LISTENER (PUBLIC) ---
        document.getElementById('password-update-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const newPassword = document.getElementById('new-password').value;
            const confirmPassword = document.getElementById('confirm-password').value;
            const statusEl = document.getElementById('password-update-status');
            const 
updateBtn = document.getElementById('updatePasswordBtn');

            if (newPassword !== confirmPassword) {
                statusEl.textContent = 'Passwords do not match.';
                statusEl.className = 'text-red-600 mt-3';
                return;
            }
            if (newPassword.length 
< 6) {
                statusEl.textContent = 'Password must be at least 6 characters.';
                statusEl.className = 'text-red-600 mt-3';
                return;
            }

            updateBtn.disabled = true;
updateBtn.textContent = 'Processing...';
            statusEl.textContent = 'Sending request to server...';
            statusEl.className = 'text-tf-primary mt-3';
try {
                const resp = await authFetch(`${API_CLIENT}?action=update-password`, {
                    method: 'PUT',
                    body: JSON.stringify({ newPassword })
                });
const result = await resp.json();

                if (resp.ok && result.status === 'Success') {
                    // CRITICAL FIX: Ensure string is on one line to prevent Unterminated string literal error
                    statusEl.textContent = 'Password changed successfully! Redirecting to login...'; 

                    statusEl.className = 'text-green-600 mt-3';
                    setTimeout(logout, 1500); 
                } else {
                    statusEl.textContent = result.message ||
'Update failed.';
                    statusEl.className = 'text-red-600 mt-3';
                }
            } catch (error) {
                statusEl.textContent = 'Network error or session expired.';
statusEl.className = 'text-red-600 mt-3';
                console.error('Password Update Error:', error);
            } finally {
                updateBtn.disabled = false;
updateBtn.textContent = 'Update & Log Out';
            }
        });
// --- INITIALIZATION ---
        window.onload = () => {
            // Try to fetch profile and then init bulk listeners (external)
            fetchProfileData().then(()=> {
                if (typeof initBulkListeners === 'function') {
                    initBulkListeners();
         
       } else {
                    console.error("Bulk listeners function not found. Make sure bulk_verification_logic.js is loaded.");
                }
            }).catch((e)=> {
                console.error('Error during profile init:', e);
             
   if (typeof initBulkListeners === 'function') initBulkListeners();
            });
loadInboxCounts();

            setInterval(sendHeartbeat, 60000);
            setInterval(loadInboxCounts, 60000);
            
            // Start in bulk tab
            showTab('bulk-verification', document.getElementById('bulk-tab-btn'));
/* --- SMALL SAFE FALLBACK (non-invasive) ---
            If the external bulk_verification_logic.js did not attach listeners
            (missing or errored), make sure the process button enables when a file
            is selected and disables otherwise.
This does NOT change logic.
            */
            try {
                ensureProcessButtonFallback();
} catch (e) {
                console.warn('Fallback init failed', e);
}
        };

        // --- Time Formatting Helper (NEW) ---
        function formatISTTime(utcTimestamp) {
            if (!utcTimestamp) return 'N/A';
const date = new Date(utcTimestamp);
            
            const options = {
                year: 'numeric',
                month: 'short',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
       
         hour12: true,
                timeZone: 'Asia/Kolkata'
            };
return date.toLocaleDateString('en-IN', options);
        }

        // placeholder for getRemainingCredits used in polling (assumes it's defined elsewhere)
        async function getRemainingCredits() {
            try {
                const resp = await authFetch(`${API_CLIENT}?action=remaining-credits`);
const json = await resp.json().catch(()=>null);
                return json || { ok: false };
} catch (e) {
                return { ok: false };
}
        }

        /* -------------------------
            Fallback helper (tiny)
            Enables/disables Start Verification button based on:
            - a) whether a file is selected
            - b) whether there is currently an active job (uses active job count element)
         
   This is safe â€” it only manipulates the button UI state and does not change any process logic.
------------------------- */
        function ensureProcessButtonFallback() {
            const fileInput = document.getElementById('csvFileInput');
const processBtn = document.getElementById('processButton');
            const activeJobCountEl = document.getElementById('active-job-count');
            const MAX_ACTIVE = 1;
// consistency with your logic

            if (!fileInput || !processBtn) return;
function updateButtonState() {
                // read active job count (fallback to 0)
                const active = Number(activeJobCountEl?.textContent || 0);
// enable only if file selected AND no active jobs
                const hasFile = fileInput.files && fileInput.files.length > 0;
processBtn.disabled = !(hasFile && active < MAX_ACTIVE);
            }

            // attach listener (safe, won't conflict if external script also uses this input)
            fileInput.addEventListener('change', updateButtonState, { passive: true });
// also observe changes to active job count (in case polling updates it later)
            const observerTarget = activeJobCountEl;
if (observerTarget) {
                const mo = new MutationObserver(updateButtonState);
mo.observe(observerTarget, { childList: true, subtree: true, characterData: true });
            }

            // initial sync (in case file was preselected)
            updateButtonState();
}
    </script>
</body>
</html>